* [Using EXPLAIN](#using-explain-statement)
* [Using H2 Debug Console](#using-h2-debug-console)
* [Performance and Usability Considerations](#performance-and-usability-considerations)
[block:api-header]
{
  "type": "basic",
  "title": "Using EXPLAIN Statement"
}
[/block]
Ignite supports "EXPLAIN ..." syntax in for reading execution plans and query performance investigation purposes.  Note that a plan cursor will contain multiple rows: the last one will contain a query for reducing node, others are for map nodes.
[block:code]
{
  "codes": [
    {
      "code": "SqlFieldsQuery sql = new SqlFieldsQuery(\n  \"explain select name from Person where age = ?\").setArgs(26); \n\nSystem.out.println(cache.query(sql).getAll());",
      "language": "java"
    }
  ]
}
[/block]
The execution plan itself is generated by H2 as described here: 
http://www.h2database.com/html/performance.html#explain_plan
[block:api-header]
{
  "type": "basic",
  "title": "Using H2 Debug Console"
}
[/block]
When developing with Ignite sometimes it is useful to check if your tables and indexes look  correctly or run some local queries against embedded in node H2 database. For that purpose, Ignite has an ability to start H2 Console. To do that you can start a local node with `IGNITE_H2_DEBUG_CONSOLE` system property or an environment variable set to `true`. The console will be opened in your browser. Probably you will need to click `Refresh` button on the Console because it can be opened before database objects initialized. 
[block:image]
{
  "images": [
    {
      "image": [
        "https://files.readme.io/41aa03f-OsddL8lfTOSLKqZWaTlI_Screen_Shot_2015-08-24_at_7.06.36_PM.png",
        "OsddL8lfTOSLKqZWaTlI_Screen Shot 2015-08-24 at 7.06.36 PM.png",
        1394,
        1018,
        "#e6e6d4"
      ]
    }
  ]
}
[/block]

[block:api-header]
{
  "type": "basic",
  "title": "Performance and Usability Considerations"
}
[/block]
There are few common pitfalls that should be noticed when running SQL queries.

1. If the query is using operator **OR** then it may use indexes not the way you would expect. For example for query `select name from Person where sex='M' and (age = 20 or age = 30)` index on field `age` will not be used even if it is obviously more selective than index on field `sex` and thus is preferable. To workaround this issue you have to rewrite the query with UNION ALL (notice that UNION without ALL will return DISTINCT rows, which will change query semantics and introduce additional performance penalty) like `select name from Person where sex='M' and age = 20 
UNION ALL 
select name from Person where sex='M' and age = 30`. This way indexes will be used correctly.

2. If query contains operator **IN** then it has two problems: it is impossible to provide variable list of parameters (you have to specify the exact list in query like `where id in (?, ?, ?)`, but you can not write it like `where id in ?` and pass array or collection) and this query will not use index. To workaround both problems you can rewrite the query in the following way: `select p.name from Person p join table(id bigint = ?) i on p.id = i.id`. Here you can provide object array (Object[]) of any length as a parameter and the query will use index on field `id`. Note that primitive arrays (int[], long[], etc..) can not be used with this syntax, you have to pass array of boxed primitives.