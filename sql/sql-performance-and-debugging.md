The following page covers these topics:
* [Using EXPLAIN](#using-explain-statement)
* [Using H2 Debug Console](#using-h2-debug-console)
* [Performance and Usability Considerations](#performance-and-usability-considerations)

To learn more on indexes tradeoffs refer to [this documentation section](http://apacheignite.readme.io/docs/indexes#indexes-tradeoffs).
[block:api-header]
{
  "type": "basic",
  "title": "Using EXPLAIN Statement"
}
[/block]
Ignite supports "EXPLAIN ..." syntax in for reading execution plans and query performance investigation purposes.  Note that a plan cursor will contain multiple rows: the last one will contain a query for reducing node, others are for map nodes.
[block:code]
{
  "codes": [
    {
      "code": "SqlFieldsQuery sql = new SqlFieldsQuery(\n  \"explain select name from Person where age = ?\").setArgs(26); \n\nSystem.out.println(cache.query(sql).getAll());",
      "language": "java"
    }
  ]
}
[/block]
The execution plan itself is generated by H2 as described here: 
http://www.h2database.com/html/performance.html#explain_plan
[block:api-header]
{
  "type": "basic",
  "title": "Using H2 Debug Console"
}
[/block]
When developing with Ignite sometimes it is useful to check if your tables and indexes look  correctly or run some local queries against embedded in node H2 database. For that purpose, Ignite has an ability to start H2 Console. To do that you can start a local node with `IGNITE_H2_DEBUG_CONSOLE` system property or an environment variable set to `true`. The console will be opened in your browser. Probably you will need to click `Refresh` button on the Console because it can be opened before database objects initialized. 
[block:image]
{
  "images": [
    {
      "image": [
        "https://files.readme.io/41aa03f-OsddL8lfTOSLKqZWaTlI_Screen_Shot_2015-08-24_at_7.06.36_PM.png",
        "OsddL8lfTOSLKqZWaTlI_Screen Shot 2015-08-24 at 7.06.36 PM.png",
        1394,
        1018,
        "#e6e6d4"
      ]
    }
  ]
}
[/block]

[block:api-header]
{
  "type": "basic",
  "title": "Performance and Usability Considerations"
}
[/block]
There are few common pitfalls that should be noticed when running SQL queries.

1. If the query is using operator **OR** then it may use indexes not the way you would expect. For example for query `select name from Person where sex='M' and (age = 20 or age = 30)` index on field `age` will not be used even if it is obviously more selective than index on field `sex` and thus is preferable. To workaround this issue you have to rewrite the query with UNION ALL (notice that UNION without ALL will return DISTINCT rows, which will change query semantics and introduce additional performance penalty) like `select name from Person where sex='M' and age = 20 
UNION ALL 
select name from Person where sex='M' and age = 30`. This way indexes will be used correctly.

2. If query contains operator **IN** then it has two problems: it is impossible to provide variable list of parameters (you have to specify the exact list in query like `where id in (?, ?, ?)`, but you can not write it like `where id in ?` and pass array or collection) and this query will not use index. To workaround both problems you can rewrite the query in the following way: `select p.name from Person p join table(id bigint = ?) i on p.id = i.id`. Here you can provide object array (Object[]) of any length as a parameter and the query will use index on field `id`. Note that primitive arrays (int[], long[], etc..) can not be used with this syntax, you have to pass array of boxed primitives.


[block:api-header]
{
  "type": "basic",
  "title": "Fast DML Operations"
}
[/block]
Usually `UPDATE` and `DELETE` statements require performing a `SELECT` query in order to prepare a set of cache entries to be processed later. In some situations, this can be avoided leading to significant performance gains by direct translation of DML statements into specific cache operations.

To summarize the content of [distributed DML](doc:dml) section, these are the reasons why `UPDATE` and `DELETE` automatically executed a `SELECT` query:

1. A complex filter is present in `WHERE` condition - we really have to perform some work to figure out entries that will be affected by DML statement as query does not tell us as it is what has to be affected.
2. _(valid only for `UPDATE`)_ Statement contains expressions - even if our `WHERE` is simple and directly points to the cache entry to be modified, and even more so if it's not, new column values could be computed by some functions or expressions. We have to run a `SELECT` to evaluate all of those in this case.
3. _(valid only for `UPDATE`)_ Distinct fields of cache entry value are updated - we have to retrieve current value for a given key first, then modify it thus making new value object, then put it back to cache.
[block:api-header]
{
  "type": "basic",
  "title": "What Makes a Fast Operation?"
}
[/block]
In accordance with the previous section, within the context of this document we call a *fast update* an `UPDATE` or `DELETE` operation that:

1. Does not require performing a `SELECT`.
2. Updates single cache entry.
3. Directly maps query "as is" to a cache operation.

For above to be possible, such operation has to satisfy following criteria:

1. Filter only by key equality, and, *optionally*, value equality - no other conditions must be present.
2. Filtering arguments for both key and value (if it's present) must be either present explicitly in query string as a constant, or must be taken from query params - in other words, `WHERE` part of a fast operation can't contain any function calls or expressions that need to be evaluated, as either would take making a `SELECT`, and that's what a fast operation strives to avoid.
3. _(valid only for `UPDATE`)_ Set only `_val` column explicitly and no other columns - this condition provides for the lack of need to `SELECT` previous value and modify its fields.
[block:api-header]
{
  "type": "basic",
  "title": "Example"
}
[/block]
Let's see an example:
[block:code]
{
  "codes": [
    {
      "code": "IgniteCache<Integer, Integer> intCache = getIntCache();\n\nintCache.query(new SqlFieldsQuery(\"UPDATE Person SET _val = ?3 WHERE _key = ?1 and _val = ?2\").setArgs(7, 1, 2));",
      "language": "java"
    }
  ]
}
[/block]
As you may see, this `UPDATE` statement
- explicitly tells us which cache entry has to be updated (by specifying `_key` that does not need to be computed but rather is provided directly),
- sets `_val` explicitly again with directly provided value thus freeing us from necessity to `SELECT` and modify existing value,
- imposts additional condition onto `_val` - cache contents will be modified only if current value for given key is equal to that of given parameter.

And thus it is effectively executed as following cache operation - please mind param indexes in previous code snippet to see for yourself that `7` corresponds to key while `1` and `2` correspond to expected old and new values for that key respectively.
[block:code]
{
  "codes": [
    {
      "code": "intCache.replace(7, 1, 2);",
      "language": "java"
    }
  ]
}
[/block]
As said before, `_val` bound is optional, so query snippet could look like this
[block:code]
{
  "codes": [
    {
      "code": "IgniteCache<Integer, Integer> intCache = getIntCache();\n\nintCache.query(new SqlFieldsQuery(\"UPDATE Person SET _val = ?2 WHERE \" +\n \"_key = ?1\").setArgs(7, 2));",
      "language": "java"
    }
  ]
}
[/block]
And it would the be directly mapped to
[block:code]
{
  "codes": [
    {
      "code": "intCache.replace(7, 2);",
      "language": "java"
    }
  ]
}
[/block]
For simplicity, above example use primitive types both for key and value, although of course either could be an object.

`DELETE` statements follow the same optimization rules - the main thing to consider is the kind of filtering:
- `_key` and, optionally, `_val` columns,
- equality comparison for both key and value,
- no expressions in condition.