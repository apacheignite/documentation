The following page covers these topics:
* [Using EXPLAIN](#using-explain-statement)
* [Using H2 Debug Console](#using-h2-debug-console)
* [SQL Performance and Usability Considerations](#sql-performance-and-usability-considerations)
* [Query Parallelism](#query-parallelism)
* [Advanced DML Optimizations](#advanced-dml-optimizations)

To learn more on indexes tradeoffs refer to [this documentation section](http://apacheignite.readme.io/docs/indexes#indexes-tradeoffs).
[block:api-header]
{
  "type": "basic",
  "title": "Using EXPLAIN Statement"
}
[/block]
Ignite supports "EXPLAIN ..." syntax for reading execution plans and query performance investigation purposes.  Note that a plan cursor will contain multiple rows: the last one will contain a query for reducing node, others are for map nodes.
[block:code]
{
  "codes": [
    {
      "code": "SqlFieldsQuery sql = new SqlFieldsQuery(\n  \"explain select name from Person where age = ?\").setArgs(26); \n\nSystem.out.println(cache.query(sql).getAll());",
      "language": "java"
    }
  ]
}
[/block]
The execution plan itself is generated by H2 as described here: 
http://www.h2database.com/html/performance.html#explain_plan
[block:api-header]
{
  "type": "basic",
  "title": "Using H2 Debug Console"
}
[/block]
When developing with Ignite, sometimes, it is useful to check if your tables and indexes look  correctly. It may also be useful to run some local queries against the embedded node in H2 database. For that purpose, Ignite has an ability to start H2 Console. To do that, you can start a local node with `IGNITE_H2_DEBUG_CONSOLE` system property or an environment variable set to `true`. The console will be opened in your browser. You may need to click the `Refresh` button on the Console because it can be opened before the database objects are initialized. 
[block:image]
{
  "images": [
    {
      "image": [
        "https://files.readme.io/41aa03f-OsddL8lfTOSLKqZWaTlI_Screen_Shot_2015-08-24_at_7.06.36_PM.png",
        "OsddL8lfTOSLKqZWaTlI_Screen Shot 2015-08-24 at 7.06.36 PM.png",
        1394,
        1018,
        "#e6e6d4"
      ]
    }
  ]
}
[/block]

[block:api-header]
{
  "title": "Query parallelism"
}
[/block]
Test
[block:api-header]
{
  "type": "basic",
  "title": "SQL Performance and Usability Considerations"
}
[/block]
There are a few common pitfalls that should be considered when running SQL queries.

1. If the query contains an **OR** operator, then indexes may not be used as expected. For example, for the query `select name from Person where sex='M' and (age = 20 or age = 30)`, index on field `sex` will be used instead of index on field `age` although the latter is a more selective index. As a workaround for this issue, you can rewrite the query with UNION ALL (notice that UNION without ALL will return DISTINCT rows, which will change the query semantics and introduce additional performance penalty). For Example:
 `select name from Person where sex='M' and age = 20 
UNION ALL 
select name from Person where sex='M' and age = 30`. 

2. If the query contains an **IN** operator, there can be two issues: First, it is impossible to provide variable list of parameters. That means that you have to specify the exact list in the query, for example, `where id in (?, ?, ?)`. You cannot write - `where id in ?` and pass an array or collection. Second, this query will not use indexes. As a workaround to both the problems, you can rewrite the query in the following way: `select p.name from Person p join table(id bigint = ?) i on p.id = i.id`. 
Here you can provide an object array (Object[]) of any length as a parameter and the query will use index on field `id`. Note that primitive arrays (int[], long[], etc..) can not be used with this syntax, you can only pass an array of boxed primitives.

Example:
[block:code]
{
  "codes": [
    {
      "code": "new SqlFieldsQuery(\n  \"select * from Person p join table(id bigint = ?) i on p.id = i.id\").setArgs(new Object[]{ new Integer[] {2, 3, 4} }))",
      "language": "java"
    }
  ]
}
[/block]
Which is converted in to the following SQL:
[block:code]
{
  "codes": [
    {
      "code": "select * from \"cache-name\".Person p join table(id bigint = (2,3,4)) i on p.id = i.id",
      "language": "sql"
    }
  ]
}
[/block]

[block:api-header]
{
  "type": "basic",
  "title": "Advanced DML Optimizations"
}
[/block]
Usually, `UPDATE` and `DELETE` statements require performing a `SELECT` query in order to prepare a set of cache entries to be processed later. In some situations, this can be avoided leading to significant performance gains by direct translation of DML statements into specific cache operations.

To summarize the content of the [distributed DML](doc:dml) section, following are the reasons why `UPDATE` and `DELETE` automatically execute a `SELECT` query:

1. A complex filtering is used in the `WHERE` clause of `UPDATE` or `DELETE` statement. This happens when a sophisticated and advanced filtering of entries is used and the DML engine needs to do extra work in order to prepare the list of the entries that will be updated by the DML statement. 
2. An `UPDATE` statement contains an expression. Even if the `WHERE` clause is simple and points to a cache entry to be modified directly with the usage of `_key` or `_value`, the execution of an expression might result in new fields' values. This is why DML engine has to execute the `SELECT` in order to evaluate the expression's execution result.
3. An `UPDATE` statement modifies specific fields belonging to a cache entry. The DML engine needs to retrieve a current cache entry first, modify it, and put it back into the cache. 

## Executing DML faster

To execute a DML operation in the fastest way, the following requirements must be met:
1. A DML operation must not trigger the `SELECT` query execution.
2. The operation has to adjust a single cache entry.

The following rules has to be followed in order to satisfy the requirements above: 
1. Filter out cache entries with the usage of `_key` and `_val` keywords only.
2. These arguments have to be used explicitly in a DML statement. Cache entries' fields or expressions must not be accessed and executed.
3. If an `UPDATE` statement is executed, then it has to update the whole cache entry (`_val`) rather than specific fields.

Let's look into the following example.
[block:code]
{
  "codes": [
    {
      "code": "cache.query(new SqlFieldsQuery(\"UPDATE Person SET _val = ?3\" +\n    \" WHERE _key = ?1 and _val = ?2\").setArgs(7, 1, 2));",
      "language": "java"
    }
  ]
}
[/block]
The `UPDATE` statement does the following:
- Explicitly tells which cache entry needs to be updated by specifying `_key` the entry belongs to and entry's expected value (`_val`).
- Updates the whole cache entry's value by using `_val` keyword.

As a result, the DML engine will execute the cache operation below as-is:
[block:code]
{
  "codes": [
    {
      "code": "cache.replace(7, 1, 2);",
      "language": "java"
    }
  ]
}
[/block]